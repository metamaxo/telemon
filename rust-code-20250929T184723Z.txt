### RUST PROJECT SNAPSHOT
root: /home/max/Crates/rust-nsm-enclave-runner
generated_at: 2025-09-29T18:47:23Z

### FILE LIST
./attestation-verifier/Cargo.toml
./attestation-verifier/src/attestation/certs.rs
./attestation-verifier/src/attestation/config.rs
./attestation-verifier/src/attestation/cose.rs
./attestation-verifier/src/attestation/errors.rs
./attestation-verifier/src/attestation/mod.rs
./attestation-verifier/src/attestation/pcr.rs
./attestation-verifier/src/attestation/types.rs
./attestation-verifier/src/attestation/util.rs
./attestation-verifier/src/attestation/verifier.rs
./attestation-verifier/src/lib.rs
./attestation-verifier/src/main.rs
./nsm-enclave-runner/Cargo.toml
./nsm-enclave-runner/src/attest.rs
./nsm-enclave-runner/src/config.rs
./nsm-enclave-runner/src/handlers.rs
./nsm-enclave-runner/src/logging.rs
./nsm-enclave-runner/src/main.rs
./nsm-enclave-runner/src/router.rs
./nsm-enclave-runner/src/runner.rs
./nsm-enclave-runner/src/server.rs
./nsm-enclave-runner/src/state.rs
./nsm-enclave-runner/src/tls.rs

### CONCATENATED SOURCES

----- FILE: attestation-verifier/Cargo.toml -----
[package]
name = "nitro-verifier"
version = "0.1.0"
edition = "2021"

[dependencies]
log = "0.4"
env_logger = "0.11"
anyhow = "1"
base64 = "0.22"
serde = { version = "1", features = ["derive"] }
serde_json = "1"

reqwest = { version = "0.12", features = ["json", "rustls-tls-native-roots"] }
tokio   = { version = "1", features = ["rt-multi-thread", "macros"] }
rand    = "0.8"
hex     = "0.4"

# COSE + CBOR
coset = "=0.3.2"
serde_cbor = "0.11"

# X.509 parsing
x509-parser = "0.16"
rustls-pemfile = "2"

# signature verification
ring = "0.17"

# certificate handling
thiserror = "1"

[dev-dependencies]
rcgen = "0.12"

----- FILE: attestation-verifier/src/attestation/certs.rs -----
use crate::attestation::errors::AttnError;
use crate::attestation::util::{now_millis, sha256_fingerprint};
use anyhow::{anyhow, Context};
use ring::signature::{self, UnparsedPublicKey};
use rustls_pemfile as pemfile;
use std::collections::HashSet;
use std::io::Cursor;
use std::path::PathBuf;
use x509_parser::prelude::*;

/// Captured data for a single trusted root certificate.
pub struct RootMetadata {
    pub fingerprint: String,
    pub subject_raw: Vec<u8>,
    pub subject_display: String,
    pub der: Vec<u8>,
}

/// Trust store with metadata and quick fingerprint lookups.
pub struct RootStore {
    pub metadata: Vec<RootMetadata>,
    pub fingerprints: HashSet<String>,
}

/// Loads PEM-encoded roots from disk and filters them against an allow-list.
pub fn load_pinned_roots(
    paths: &[PathBuf],
    allow_fps: &HashSet<String>,
) -> anyhow::Result<RootStore> {
    let mut metadata = Vec::new();
    let mut fps = HashSet::new();

    for path in paths {
        let bytes = std::fs::read(path).with_context(|| format!("read {:?}", path))?;
        let mut cursor = Cursor::new(&bytes);
        let certs = pemfile::certs(&mut cursor)
            .collect::<Result<Vec<_>, _>>()
            .map_err(|e| anyhow!("parse PEM in {:?}: {e:?}", path))?;
        for der in certs {
            let der_bytes = der.as_ref();
            let fp = sha256_fingerprint(der_bytes);
            if !allow_fps.is_empty() && !allow_fps.contains(&fp) {
                continue;
            }
            let (_, cert) = parse_x509_certificate(der_bytes)
                .map_err(|e| anyhow!("parse root certificate {:?}: {e}", path))?;
            metadata.push(RootMetadata {
                fingerprint: fp.clone(),
                subject_raw: cert.subject().as_raw().to_vec(),
                subject_display: format!("{}", cert.subject()),
                der: der_bytes.to_vec(),
            });
            fps.insert(fp);
        }
    }

    anyhow::ensure!(!metadata.is_empty(), "no roots loaded");

    Ok(RootStore {
        metadata,
        fingerprints: fps,
    })
}

/// Minimal certificate chain summary produced after validation.
pub struct ChainSummary {
    pub leaf_fingerprint: String,
    pub root_fingerprint: String,
    pub root_subject: String,
}

/// Validates the attestation leaf + intermediates against the pinned roots.
pub fn verify_chain(
    leaf_der: &[u8],
    intermediates: &[Vec<u8>],
    store: &RootStore,
) -> Result<ChainSummary, AttnError> {
    verify_manually(leaf_der, intermediates, store)
}

fn verify_manually(
    leaf_der: &[u8],
    intermediates: &[Vec<u8>],
    store: &RootStore,
) -> Result<ChainSummary, AttnError> {
    let (_, leaf_cert) = parse_x509_certificate(leaf_der)
        .map_err(|e| AttnError::ChainBuild(format!("parse leaf cert: {e}")))?;
    let now = (now_millis() / 1000) as i64;
    ensure_validity(&leaf_cert, now, "leaf")?;
    ensure_basic_constraints(&leaf_cert, false)?;

    let mut ordered: Vec<Vec<u8>> = Vec::with_capacity(1 + intermediates.len());
    ordered.push(leaf_der.to_vec());
    let mut remaining: Vec<Vec<u8>> = intermediates.to_vec();
    let mut issuer_raw = leaf_cert.tbs_certificate.issuer.as_raw().to_vec();

    for _ in 0..=remaining.len() {
        if let Some(root_meta) = find_root_by_subject(&issuer_raw, store) {
            return verify_signatures(ordered, remaining, store, root_meta, now);
        }

        let position = remaining.iter().position(|der| {
            parse_x509_certificate(der)
                .map(|(_, cert)| cert.tbs_certificate.subject.as_raw() == issuer_raw.as_slice())
                .unwrap_or(false)
        });

        let idx = match position {
            Some(i) => i,
            None => break,
        };

        let parent_der = remaining.swap_remove(idx);
        let (_, cert) = parse_x509_certificate(&parent_der).map_err(|e| {
            AttnError::ChainBuild(format!("parse intermediate certificate failed: {e}"))
        })?;
        ensure_validity(&cert, now, "intermediate")?;
        ensure_basic_constraints(&cert, true)?;
        issuer_raw = cert.tbs_certificate.issuer.as_raw().to_vec();
        ordered.push(parent_der);
    }

    let root_meta = find_root_by_subject(&issuer_raw, store).ok_or_else(|| {
        AttnError::ChainBuild("could not match attestation chain to trusted root".into())
    })?;

    verify_signatures(ordered, remaining, store, root_meta, now)
}

fn verify_signatures(
    ordered: Vec<Vec<u8>>,
    remaining: Vec<Vec<u8>>,
    store: &RootStore,
    root_meta: &RootMetadata,
    now: i64,
) -> Result<ChainSummary, AttnError> {
    if !remaining.is_empty() {
        return Err(AttnError::ChainBuild(
            "unused certificates left in cabundle".into(),
        ));
    }

    let (_, root_cert) = parse_x509_certificate(&root_meta.der)
        .map_err(|e| AttnError::ChainBuild(format!("parse root certificate: {e}")))?;

    let mut parent_subject_raw = root_cert.tbs_certificate.subject.as_raw().to_vec();
    let mut parent_pub_key = root_cert
        .tbs_certificate
        .subject_pki
        .subject_public_key
        .data
        .to_vec();

    for (idx, der) in ordered.iter().enumerate().rev() {
        let (_, cert) = parse_x509_certificate(der)
            .map_err(|e| AttnError::ChainBuild(format!("parse chain certificate: {e}")))?;
        let role = if idx == 0 { "leaf" } else { "intermediate" };
        ensure_validity(&cert, now, role)?;
        ensure_basic_constraints(&cert, idx != 0)?;

        if cert.tbs_certificate.issuer.as_raw() != parent_subject_raw.as_slice() {
            return Err(AttnError::ChainBuild(format!(
                "issuer mismatch (role={role})"
            )));
        }

        let algo_oid = &cert.signature_algorithm.algorithm;
        let alg = map_signature_oid(algo_oid).map_err(AttnError::ChainBuild)?;
        let verifier = UnparsedPublicKey::new(alg, &parent_pub_key);
        verifier
            .verify(
                cert.tbs_certificate.as_ref(),
                cert.signature_value.data.as_ref(),
            )
            .map_err(|_| {
                AttnError::ChainBuild(format!(
                    "certificate signature verification failed ({role})"
                ))
            })?;

        parent_subject_raw = cert.tbs_certificate.subject.as_raw().to_vec();
        parent_pub_key = cert
            .tbs_certificate
            .subject_pki
            .subject_public_key
            .data
            .to_vec();
    }

    let leaf_fingerprint = sha256_fingerprint(ordered.first().expect("leaf exists").as_slice());

    if !store.fingerprints.contains(&root_meta.fingerprint) {
        return Err(AttnError::RootUntrusted);
    }

    Ok(ChainSummary {
        leaf_fingerprint,
        root_fingerprint: root_meta.fingerprint.clone(),
        root_subject: root_meta.subject_display.clone(),
    })
}

fn find_root_by_subject<'a>(subject_raw: &[u8], store: &'a RootStore) -> Option<&'a RootMetadata> {
    store
        .metadata
        .iter()
        .find(|meta| meta.subject_raw.as_slice() == subject_raw)
}

fn ensure_validity(cert: &X509Certificate<'_>, now: i64, label: &str) -> Result<(), AttnError> {
    let not_before = cert.validity().not_before.timestamp();
    let not_after = cert.validity().not_after.timestamp();
    if now < not_before || now > not_after {
        return Err(AttnError::ChainBuild(format!(
            "{label} certificate not valid at current time (nb={not_before} na={not_after} now={now})"
        )));
    }
    Ok(())
}

fn ensure_basic_constraints(cert: &X509Certificate<'_>, expect_ca: bool) -> Result<(), AttnError> {
    let bc = cert
        .basic_constraints()
        .map_err(|e| AttnError::ChainBuild(format!("basicConstraints parse error: {e}")))?;
    if expect_ca {
        let bc =
            bc.ok_or_else(|| AttnError::ChainBuild("missing basicConstraints on CA".into()))?;
        if !bc.value.ca {
            return Err(AttnError::ChainBuild(
                "certificate missing CA=true in basicConstraints".into(),
            ));
        }
    } else if let Some(bc) = bc {
        if bc.value.ca {
            return Err(AttnError::ChainBuild(
                "leaf certificate unexpectedly marked as CA".into(),
            ));
        }
    }

    let ku = cert
        .key_usage()
        .map_err(|e| AttnError::ChainBuild(format!("keyUsage parse error: {e}")))?;
    if expect_ca {
        let ku = ku.ok_or_else(|| AttnError::ChainBuild("missing keyUsage on CA".into()))?;
        if !ku.value.key_cert_sign() {
            return Err(AttnError::ChainBuild(
                "CA certificate missing keyCertSign usage".into(),
            ));
        }
    } else if let Some(ku) = ku {
        if ku.value.key_cert_sign() {
            return Err(AttnError::ChainBuild(
                "leaf certificate unexpectedly has keyCertSign usage".into(),
            ));
        }
    }

    Ok(())
}

fn map_signature_oid<'a>(
    oid: &x509_parser::der_parser::oid::Oid<'a>,
) -> Result<&'static dyn signature::VerificationAlgorithm, String> {
    let oid_str = oid.to_string();
    let alg: &'static dyn signature::VerificationAlgorithm = match oid_str.as_str() {
        "1.2.840.10045.4.3.2" => &signature::ECDSA_P256_SHA256_ASN1,
        "1.2.840.10045.4.3.3" => &signature::ECDSA_P384_SHA384_ASN1,
        "1.2.840.113549.1.1.11" => &signature::RSA_PKCS1_2048_8192_SHA256,
        "1.2.840.113549.1.1.12" => &signature::RSA_PKCS1_2048_8192_SHA384,
        "1.2.840.113549.1.1.13" => &signature::RSA_PKCS1_2048_8192_SHA512,
        other => {
            return Err(format!(
                "unsupported certificate signature algorithm OID {other}"
            ))
        }
    };
    Ok(alg)
}

----- FILE: attestation-verifier/src/attestation/config.rs -----
use std::{
    collections::{HashMap, HashSet},
    path::PathBuf,
    time::Duration,
};

#[derive(Debug, Clone)]
/// Parameters that drive signature verification, trust anchors, and policy checks.
pub struct VerifierConfig {
    /// One or more PEM files containing AWS Nitro Enclaves root(s) you trust.
    pub root_pem_paths: Vec<PathBuf>,
    /// Optional SHA-256 fingerprints you accept for roots (uppercase hex with colons).
    pub allowed_root_fingerprints: HashSet<String>,
    /// Freshness window for attestation timestamp (e.g., 5 minutes).
    pub freshness: Duration,
    /// Expected PCR values (index -> 48-byte SHA384).
    pub expected_pcrs: HashMap<u8, Vec<u8>>,
    /// Optional expected measurement (PCR0 shortcut).
    pub expected_measurement: Option<Vec<u8>>,
    /// If set, require TLS SPKI to match the attested SPKI.
    pub bind_tls_spki: bool,
}

impl Default for VerifierConfig {
    fn default() -> Self {
        Self {
            root_pem_paths: Vec::new(),
            allowed_root_fingerprints: HashSet::new(),
            freshness: Duration::from_secs(300),
            expected_pcrs: HashMap::new(),
            expected_measurement: None,
            bind_tls_spki: true,
        }
    }
}

----- FILE: attestation-verifier/src/attestation/cose.rs -----
use crate::attestation::errors::AttnError;
use base64::engine::general_purpose::STANDARD as b64;
use base64::Engine;
use coset::{CborSerializable, CoseSign1, TaggedCborSerializable};
use hex;
use ring::signature::{self, UnparsedPublicKey};
use serde_cbor::Value as CborValue;
use std::collections::HashMap;

#[derive(Debug)]
/// Decoded payload extracted from the COSE_Sign1 attestation document.
pub struct ParsedCose {
    pub nonce: Vec<u8>,
    pub public_key: Vec<u8>,
    pub user_data: Option<Vec<u8>>,
    pub module_id: String,
    pub digest: String,
    pub timestamp_ms: u64,
    pub pcrs: HashMap<String, Vec<u8>>,
}

/// Validates the COSE signature using the attestation leaf public key and
/// returns the parsed CBOR payload.
pub fn verify_quote(quote_b64: &str, leaf_public_key: &[u8]) -> Result<ParsedCose, AttnError> {
    let quote = b64
        .decode(quote_b64.as_bytes())
        .map_err(|e| AttnError::Decode(format!("quote_b64: {e}")))?;

    let sign1 = CoseSign1::from_tagged_slice(&quote)
        .or_else(|_| CoseSign1::from_slice(&quote))
        .map_err(|e| AttnError::CoseInvalid(format!("parse COSE_Sign1: {e:?}")))?;

    let alg = sign1
        .protected
        .header
        .alg
        .as_ref()
        .ok_or_else(|| AttnError::CoseInvalid("missing COSE alg".into()))?;

    let (ring_alg, expected_sig_len) = match alg {
        coset::Algorithm::Assigned(coset::iana::Algorithm::ES256) => {
            (&signature::ECDSA_P256_SHA256_FIXED, 64)
        }
        coset::Algorithm::Assigned(coset::iana::Algorithm::ES384) => {
            (&signature::ECDSA_P384_SHA384_FIXED, 96)
        }
        other => {
            return Err(AttnError::CoseInvalid(format!(
                "unsupported COSE alg: {:?}",
                other
            )))
        }
    };

    let unparsed = UnparsedPublicKey::new(ring_alg, leaf_public_key);
    sign1
        .verify_signature(&[], |sig, data| {
            let raw = normalize_ecdsa_signature(sig, expected_sig_len)
                .map_err(|e| AttnError::CoseInvalid(e))?;
            unparsed
                .verify(data, &raw)
                .map_err(|_| AttnError::CoseInvalid("ring verification failed".into()))
        })
        .map_err(|e| {
            AttnError::CoseInvalid(format!("COSE signature verification failed: {e:?}"))
        })?;

    let payload_bytes = sign1
        .payload
        .as_ref()
        .ok_or_else(|| AttnError::CoseInvalid("missing COSE payload".into()))?;

    let payload: CborValue = serde_cbor::from_slice(payload_bytes)
        .map_err(|e| AttnError::CoseInvalid(format!("decode CBOR payload: {e}")))?;

    let fields = extract_fields(&payload)?;

    Ok(ParsedCose {
        nonce: fields.nonce,
        public_key: fields.public_key,
        user_data: fields.user_data,
        module_id: fields.module_id,
        digest: fields.digest,
        timestamp_ms: fields.timestamp_ms,
        pcrs: fields.pcrs,
    })
}

struct PayloadFields {
    nonce: Vec<u8>,
    public_key: Vec<u8>,
    user_data: Option<Vec<u8>>,
    module_id: String,
    digest: String,
    timestamp_ms: u64,
    pcrs: HashMap<String, Vec<u8>>,
}

fn extract_fields(payload: &CborValue) -> Result<PayloadFields, AttnError> {
    let map = match payload {
        CborValue::Map(m) => m,
        _ => return Err(AttnError::CoseInvalid("payload is not a map".into())),
    };

    let mut nonce = None;
    let mut public_key = None;
    let mut user_data = None;
    let mut module_id = None;
    let mut digest = None;
    let mut timestamp = None;
    let mut pcrs: HashMap<String, Vec<u8>> = HashMap::new();

    for (key, value) in map {
        if let Some(name) = key_as_string(key) {
            match name.as_str() {
                "nonce" => nonce = Some(bytes_from_value(value, "nonce")?),
                "public_key" => public_key = Some(bytes_from_value(value, "public_key")?),
                "user_data" => user_data = Some(bytes_from_value(value, "user_data")?),
                "module_id" => module_id = Some(string_from_value(value, "module_id")?),
                "digest" => digest = Some(string_from_value(value, "digest")?),
                "timestamp" => timestamp = Some(int_from_value(value, "timestamp")?),
                "pcrs" => {
                    pcrs = pcr_map_from_value(value)?;
                }
                _ => {}
            }
        }
    }

    Ok(PayloadFields {
        nonce: nonce.ok_or_else(|| AttnError::CoseInvalid("nonce missing".into()))?,
        public_key: public_key
            .ok_or_else(|| AttnError::CoseInvalid("public_key missing".into()))?,
        user_data,
        module_id: module_id.ok_or_else(|| AttnError::CoseInvalid("module_id missing".into()))?,
        digest: digest.ok_or_else(|| AttnError::CoseInvalid("digest missing".into()))?,
        timestamp_ms: timestamp
            .ok_or_else(|| AttnError::CoseInvalid("timestamp missing".into()))?,
        pcrs,
    })
}

fn key_as_string(key: &CborValue) -> Option<String> {
    match key {
        CborValue::Text(s) => Some(s.clone()),
        CborValue::Integer(i) => Some(i.to_string()),
        CborValue::Bytes(b) => Some(hex::encode(b)),
        _ => None,
    }
}

fn bytes_from_value(value: &CborValue, field: &str) -> Result<Vec<u8>, AttnError> {
    match value {
        CborValue::Bytes(b) => Ok(b.clone()),
        other => Err(AttnError::CoseInvalid(format!(
            "{field} expected bytes, got {:?}",
            other
        ))),
    }
}

fn string_from_value(value: &CborValue, field: &str) -> Result<String, AttnError> {
    match value {
        CborValue::Text(s) => Ok(s.clone()),
        other => Err(AttnError::CoseInvalid(format!(
            "{field} expected text, got {:?}",
            other
        ))),
    }
}

fn int_from_value(value: &CborValue, field: &str) -> Result<u64, AttnError> {
    match value {
        CborValue::Integer(i) if *i >= 0 => Ok(*i as u64),
        other => Err(AttnError::CoseInvalid(format!(
            "{field} expected non-negative integer, got {:?}",
            other
        ))),
    }
}

fn pcr_map_from_value(value: &CborValue) -> Result<HashMap<String, Vec<u8>>, AttnError> {
    let entries = match value {
        CborValue::Map(m) => m,
        other => {
            return Err(AttnError::CoseInvalid(format!(
                "pcrs expected map, got {:?}",
                other
            )))
        }
    };
    let mut out = HashMap::with_capacity(entries.len());
    for (k, v) in entries {
        let key = key_as_string(k)
            .ok_or_else(|| AttnError::CoseInvalid("pcrs key not convertible to string".into()))?;
        let value_bytes = bytes_from_value(v, "pcr value")?;
        out.insert(key, value_bytes);
    }
    Ok(out)
}

/// Accepts either raw fixed-width signatures or DER-encoded ones and normalises to raw.
fn normalize_ecdsa_signature(sig: &[u8], expected_len: usize) -> Result<Vec<u8>, String> {
    if sig.len() == expected_len {
        return Ok(sig.to_vec());
    }
    if sig.len() < 8 || sig.first() != Some(&0x30) {
        return Err(format!(
            "unexpected ECDSA signature format (len={})",
            sig.len()
        ));
    }
    let total_len = sig[1] as usize;
    if total_len + 2 != sig.len() {
        return Err(format!(
            "DER signature length mismatch (declared={}, actual={})",
            total_len,
            sig.len()
        ));
    }
    let mut idx = 2;
    let r = der_read_int(sig, &mut idx, expected_len / 2)?;
    let s = der_read_int(sig, &mut idx, expected_len / 2)?;
    if idx != sig.len() {
        return Err("unexpected trailing data in DER signature".into());
    }
    let mut out = Vec::with_capacity(expected_len);
    out.extend_from_slice(&r);
    out.extend_from_slice(&s);
    Ok(out)
}

fn der_read_int(sig: &[u8], idx: &mut usize, part_len: usize) -> Result<Vec<u8>, String> {
    if *idx >= sig.len() || sig[*idx] != 0x02 {
        return Err("expected INTEGER tag in DER signature".into());
    }
    *idx += 1;
    if *idx >= sig.len() {
        return Err("incomplete DER length".into());
    }
    let mut len = sig[*idx] as usize;
    *idx += 1;
    if len & 0x80 != 0 {
        let bytes = len & 0x7F;
        if bytes == 0 || bytes > 2 || *idx + bytes > sig.len() {
            return Err("unsupported DER length encoding".into());
        }
        len = 0;
        for _ in 0..bytes {
            len = (len << 8) | sig[*idx] as usize;
            *idx += 1;
        }
    }
    if *idx + len > sig.len() {
        return Err("DER INTEGER overruns signature buffer".into());
    }
    let mut value = &sig[*idx..*idx + len];
    *idx += len;
    while !value.is_empty() && value[0] == 0 {
        value = &value[1..];
    }
    if value.len() > part_len {
        return Err(format!(
            "DER INTEGER too large (len={}, expected <= {})",
            value.len(),
            part_len
        ));
    }
    let mut out = vec![0u8; part_len];
    let start = part_len - value.len();
    out[start..].copy_from_slice(value);
    Ok(out)
}

----- FILE: attestation-verifier/src/attestation/errors.rs -----
use thiserror::Error;

#[derive(Debug, Error)]
/// High-level error taxonomy consumers can match on when verification fails.
pub enum AttnError {
    #[error("nonce mismatch")]
    NonceMismatch,
    #[error("stale timestamp")]
    StaleTimestamp,
    #[error("attestation COSE/CBOR invalid or signature failed: {0}")]
    CoseInvalid(String),
    #[error("certificate chain build failed: {0}")]
    ChainBuild(String),
    #[error("root not in allowlist")]
    RootUntrusted,
    #[error("PCR policy failed: {0}")]
    PcrPolicy(String),
    #[error("SPKI binding failed")]
    SpkiBinding,
    #[error("decode error: {0}")]
    Decode(String),
    #[error("internal: {0}")]
    Internal(String),
}

----- FILE: attestation-verifier/src/attestation/mod.rs -----
pub mod config;
pub mod errors;
pub mod types;
pub mod verifier;

mod certs;
mod cose;
mod pcr;
mod util;

pub use config::VerifierConfig;
pub use errors::AttnError;
pub use types::{AttestationBlock, AttestationEnvelope, VerifiedAttestation};
pub use verifier::Verifier;

----- FILE: attestation-verifier/src/attestation/pcr.rs -----
use crate::attestation::config::VerifierConfig;
use crate::attestation::cose::ParsedCose;
use crate::attestation::types::AttestationBlock;
use crate::attestation::util::{eq_hex, sha256_fingerprint};
use hex::FromHex;
use std::fmt::Write;

/// Ensures measured PCRs match local policy (including optional PCR0 shortcut).
pub fn verify_pcr_policy(
    cfg: &VerifierConfig,
    block: &AttestationBlock,
    parsed: &ParsedCose,
) -> Result<(), String> {
    if parsed.digest != block.digest {
        return Err(format!(
            "digest mismatch between COSE payload ('{}') and response ('{}')",
            parsed.digest, block.digest
        ));
    }
    if parsed.digest.to_ascii_uppercase() != "SHA384" {
        return Err(format!(
            "unexpected digest '{}' (expected SHA384)",
            parsed.digest
        ));
    }

    // Cross-check measurement_hex with PCR0 if both present.
    if let Some(measurement_hex) = &block.measurement_hex {
        if let Some(pcr0_hex) = block.pcrs_hex.get("0") {
            if !eq_hex(measurement_hex, pcr0_hex) {
                return Err("measurement_hex != PCR0".into());
            }
        }
    }

    // Ensure parsed PCR map aligns with JSON snapshot for indexes we care about.
    for (idx_str, hex_value) in &block.pcrs_hex {
        if let Some(parsed_bytes) = parsed.pcrs.get(idx_str) {
            let json_bytes = Vec::from_hex(hex_value)
                .map_err(|e| format!("PCR{idx_str} hex parse error: {e}"))?;
            if parsed_bytes != &json_bytes {
                let mut msg = String::new();
                write!(
                    &mut msg,
                    "PCR{} mismatch between payload ({}) and response ({})",
                    idx_str,
                    sha256_fingerprint(parsed_bytes),
                    sha256_fingerprint(&json_bytes)
                )
                .ok();
                return Err(msg);
            }
        }
    }

    for (&idx, want_bytes) in &cfg.expected_pcrs {
        let key = idx.to_string();
        let Some(hex_value) = block.pcrs_hex.get(&key) else {
            return Err(format!("missing PCR{idx} in response"));
        };
        let actual = Vec::from_hex(hex_value).map_err(|e| format!("PCR{idx} parse error: {e}"))?;
        if &actual != want_bytes {
            return Err(format!("PCR{idx} mismatch"));
        }
    }

    if let Some(expected) = &cfg.expected_measurement {
        let source_hex = block
            .pcrs_hex
            .get("0")
            .or(block.measurement_hex.as_ref())
            .ok_or_else(|| "missing PCR0/measurement".to_string())?;
        let actual =
            Vec::from_hex(source_hex).map_err(|e| format!("measurement parse error: {e}"))?;
        if &actual != expected {
            return Err("PCR0 measurement mismatch".into());
        }
    }

    Ok(())
}

----- FILE: attestation-verifier/src/attestation/types.rs -----
use serde::Deserialize;
use std::collections::HashMap;

#[derive(Debug)]
/// Summary returned to callers after successful verification.
pub struct VerifiedAttestation {
    pub module_id: String,
    pub timestamp_ms: u64,
    pub leaf_fingerprint_sha256: String,
    pub root_fingerprint_sha256: String,
    pub used_root_subject: String,
    pub pcrs_ok: bool,
    pub spki_bound: bool,
}

#[derive(Debug, Deserialize)]
/// Shape of the JSON envelope produced by the enclave runner.
pub struct AttestationEnvelope {
    pub attestation: AttestationBlock,
    /// Runner HTTPS leaf cert (DER, base64) – used only for SPKI binding (optional).
    #[serde(default)]
    pub cert_der_b64: Option<String>,
}

#[derive(Debug, Deserialize)]
/// Inner attestation block that mirrors the NSM payload and helper metadata.
pub struct AttestationBlock {
    /// Raw NSM AttestationDocument, base64 (COSE_Sign1 over CBOR payload)
    pub quote_b64: String,
    /// Nonce you sent (base64)
    pub nonce_b64: String,
    /// Enclave TLS SPKI (DER, base64)
    pub spki_der_b64: String,
    pub policy: Option<String>,
    pub runner_version: Option<String>,
    /// 0..N intermediates/root (DER, base64)
    #[serde(default)]
    pub cabundle_der_b64: Vec<String>,
    /// Attestation signing cert (leaf, DER, base64)
    pub attestation_cert_der_b64: String,
    /// PCR map (index -> hex)
    #[serde(default)]
    pub pcrs_hex: HashMap<String, String>,
    /// Shortcut for PCR0 (hex)
    #[serde(default)]
    pub measurement_hex: Option<String>,
    pub module_id: String,
    pub digest: String, // expect "SHA384"
    pub timestamp_ms: u64,
    #[serde(default)]
    pub user_data_b64: Option<String>,
}

----- FILE: attestation-verifier/src/attestation/util.rs -----
use crate::attestation::errors::AttnError;
use base64::engine::general_purpose::STANDARD as b64;
use base64::Engine;
use ring::digest::{digest, SHA256};
use std::time::{SystemTime, UNIX_EPOCH};

/// Formats a SHA-256 digest as uppercase colon-separated hex.
pub fn sha256_fingerprint(data: &[u8]) -> String {
    let d = digest(&SHA256, data);
    let mut out = String::with_capacity(d.as_ref().len() * 3);
    for (idx, byte) in d.as_ref().iter().enumerate() {
        if idx > 0 {
            out.push(':');
        }
        out.push_str(&format!("{:02X}", byte));
    }
    out
}

/// Constant-time comparison for equal-length byte slices.
pub fn constant_time_eq(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }
    let mut acc = 0u8;
    for (x, y) in a.iter().zip(b) {
        acc |= x ^ y;
    }
    acc == 0
}

/// Returns the current Unix timestamp in milliseconds.
pub fn now_millis() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis() as u64
}

/// Case-insensitive hex comparison supporting optional `0x` prefixes.
pub fn eq_hex(a: &str, b: &str) -> bool {
    let na = a.trim_start_matches("0x");
    let nb = b.trim_start_matches("0x");
    na.eq_ignore_ascii_case(nb)
}

/// Base64-decodes `value`, tagging errors with the provided label.
pub fn decode_b64(label: &str, value: &str) -> Result<Vec<u8>, AttnError> {
    b64.decode(value.as_bytes())
        .map_err(|e| AttnError::Decode(format!("{label}: {e}")))
}

----- FILE: attestation-verifier/src/attestation/verifier.rs -----
use super::config::VerifierConfig;
use super::cose::verify_quote;
use super::errors::AttnError;
use super::pcr::verify_pcr_policy;
use super::types::{AttestationEnvelope, VerifiedAttestation};
use super::util::{constant_time_eq, decode_b64, now_millis};
use crate::attestation::certs::{load_pinned_roots, verify_chain, ChainSummary, RootStore};
use x509_parser::prelude::*;

/// Attestation verifier with cached trust anchors.
pub struct Verifier {
    cfg: VerifierConfig,
    roots: RootStore,
    fingerprint_subject: std::collections::HashMap<String, String>,
}

impl Verifier {
    /// Constructs a verifier and pre-loads root certificates according to `cfg`.
    pub fn new(cfg: VerifierConfig) -> anyhow::Result<Self> {
        let root_store = load_pinned_roots(&cfg.root_pem_paths, &cfg.allowed_root_fingerprints)?;
        let fingerprint_subject = root_store
            .metadata
            .iter()
            .map(|meta| (meta.fingerprint.clone(), meta.subject_display.clone()))
            .collect();
        Ok(Self {
            cfg,
            roots: root_store,
            fingerprint_subject,
        })
    }

    /// Verifies an attestation JSON document produced by the enclave runner.
    pub fn verify_json(
        &self,
        json: &str,
        expected_nonce_b64: &str,
    ) -> Result<VerifiedAttestation, AttnError> {
        let env: AttestationEnvelope =
            serde_json::from_str(json).map_err(|e| AttnError::Decode(format!("json: {e}")))?;
        self.verify_envelope(&env, expected_nonce_b64)
    }

    /// Verifies a parsed attestation envelope against the expected nonce.
    pub fn verify_envelope(
        &self,
        env: &AttestationEnvelope,
        expected_nonce_b64: &str,
    ) -> Result<VerifiedAttestation, AttnError> {
        let block = &env.attestation;

        if block.nonce_b64 != expected_nonce_b64 {
            return Err(AttnError::NonceMismatch);
        }

        let now_ms = now_millis();
        let drift = now_ms.abs_diff(block.timestamp_ms);
        if drift > self.cfg.freshness.as_millis() as u64 {
            return Err(AttnError::StaleTimestamp);
        }

        let leaf_der = decode_b64("attestation_cert_der_b64", &block.attestation_cert_der_b64)?;
        let leaf_cert = parse_x509_certificate(&leaf_der)
            .map_err(|e| AttnError::ChainBuild(format!("parse attestation leaf: {e}")))?
            .1;
        let leaf_public_key = leaf_cert
            .tbs_certificate
            .subject_pki
            .subject_public_key
            .data
            .to_vec();

        let parsed_quote = verify_quote(&block.quote_b64, &leaf_public_key)?;

        let expected_nonce = decode_b64("expected nonce", expected_nonce_b64)?;
        let attestation_nonce = decode_b64("attestation nonce", &block.nonce_b64)?;
        if attestation_nonce != expected_nonce {
            return Err(AttnError::NonceMismatch);
        }
        if parsed_quote.nonce != expected_nonce {
            return Err(AttnError::NonceMismatch);
        }

        let attested_spki = decode_b64("spki_der_b64", &block.spki_der_b64)?;
        if parsed_quote.public_key != attested_spki {
            return Err(AttnError::CoseInvalid(
                "attestation payload public_key mismatch".into(),
            ));
        }

        if let Some(user_data_b64) = &block.user_data_b64 {
            let user_data = decode_b64("user_data_b64", user_data_b64)?;
            let payload_ud = parsed_quote
                .user_data
                .as_ref()
                .ok_or_else(|| AttnError::CoseInvalid("user_data missing in payload".into()))?;
            if &user_data != payload_ud {
                return Err(AttnError::CoseInvalid(
                    "user_data mismatch between payload and response".into(),
                ));
            }
        }

        if parsed_quote.module_id != block.module_id {
            return Err(AttnError::CoseInvalid(
                "module_id mismatch between payload and response".into(),
            ));
        }
        if parsed_quote.timestamp_ms != block.timestamp_ms {
            return Err(AttnError::CoseInvalid(
                "timestamp mismatch between payload and response".into(),
            ));
        }

        let intermediates = decode_cabundle(&block.cabundle_der_b64)?;
        let ChainSummary {
            leaf_fingerprint,
            root_fingerprint,
            root_subject,
        } = verify_chain(&leaf_der, &intermediates, &self.roots)?;

        verify_pcr_policy(&self.cfg, block, &parsed_quote).map_err(|e| AttnError::PcrPolicy(e))?;

        let mut spki_bound = true;
        if self.cfg.bind_tls_spki {
            spki_bound = match (&env.cert_der_b64, &block.spki_der_b64) {
                (Some(tls_cert_b64), spki_b64) => {
                    let tls_der = decode_b64("cert_der_b64", tls_cert_b64)?;
                    let tls_spki = extract_spki(&tls_der)
                        .map_err(|e| AttnError::Internal(format!("extract TLS SPKI: {e}")))?;
                    let att_spki = decode_b64("spki_der_b64", spki_b64)?;
                    constant_time_eq(&tls_spki, &att_spki)
                }
                _ => false,
            };
            if !spki_bound {
                return Err(AttnError::SpkiBinding);
            }
        }

        let used_root_subject = self
            .fingerprint_subject
            .get(&root_fingerprint)
            .cloned()
            .unwrap_or(root_subject);

        Ok(VerifiedAttestation {
            module_id: block.module_id.clone(),
            timestamp_ms: block.timestamp_ms,
            leaf_fingerprint_sha256: leaf_fingerprint,
            root_fingerprint_sha256: root_fingerprint,
            used_root_subject,
            pcrs_ok: true,
            spki_bound,
        })
    }
}

/// Decodes base64-encoded intermediates from the attestation response, keeping non-self-signed nodes.
fn decode_cabundle(entries: &[String]) -> Result<Vec<Vec<u8>>, AttnError> {
    let mut out = Vec::with_capacity(entries.len());
    for entry in entries {
        let der = decode_b64("cabundle entry", entry)?;
        if !is_self_signed(&der)? {
            out.push(der);
        }
    }
    Ok(out)
}

fn is_self_signed(der: &[u8]) -> Result<bool, AttnError> {
    let (_, cert) = x509_parser::parse_x509_certificate(der)
        .map_err(|e| AttnError::Decode(format!("cabundle parse: {e}")))?;
    Ok(cert.tbs_certificate.subject == cert.tbs_certificate.issuer)
}

fn extract_spki(cert_der: &[u8]) -> Result<Vec<u8>, String> {
    let (_, cert) =
        x509_parser::parse_x509_certificate(cert_der).map_err(|e| format!("x509 parse: {e}"))?;
    Ok(cert.tbs_certificate.subject_pki.raw.to_vec())
}

----- FILE: attestation-verifier/src/lib.rs -----
pub mod attestation;

----- FILE: attestation-verifier/src/main.rs -----
use base64::engine::general_purpose::STANDARD as b64;
use base64::Engine;
use env_logger::Env;
use nitro_verifier::attestation::{AttnError, Verifier, VerifierConfig};
use rand::RngCore;
use serde_json::Value as JsonValue;
use std::{collections::HashMap, env, fs, path::PathBuf, time::Duration};

type CliResult<T> = Result<T, anyhow::Error>;

const AWS_COMMERCIAL_ROOT_FP: &str = "64:1A:03:21:A3:E2:44:EF:E4:56:46:31:95:D6:06:31:7E:D7:CD:CC:3C:17:56:E0:98:93:F3:C6:8F:79:BB:5B";

/// CLI entrypoint: loads policy configuration, fetches attestation, and prints a summary.
#[tokio::main]
async fn main() -> CliResult<()> {
    env_logger::Builder::from_env(Env::default().default_filter_or("info"))
        .format_timestamp_secs()
        .try_init()
        .ok();

    let root_pem = resolve_root_pem_path()?;
    let expected_pcrs = load_expected_pcrs()?;
    let expected_measurement = load_expected_measurement().ok();

    let mut cfg = VerifierConfig::default();
    cfg.root_pem_paths = vec![root_pem];
    cfg.allowed_root_fingerprints = vec![AWS_COMMERCIAL_ROOT_FP.to_string()]
        .into_iter()
        .collect();
    cfg.expected_pcrs = expected_pcrs;
    cfg.expected_measurement = expected_measurement;
    cfg.freshness = Duration::from_secs(300);

    let verifier = Verifier::new(cfg)?;

    let (nonce_b64, attestation_json) = fetch_attestation().await?;

    match verifier.verify_json(&attestation_json, &nonce_b64) {
        Ok(result) => {
            println!("✅ Attestation verified:");
            println!("  module_id      : {}", result.module_id);
            println!("  timestamp_ms   : {}", result.timestamp_ms);
            println!("  leaf SHA256    : {}", result.leaf_fingerprint_sha256);
            println!("  root SHA256    : {}", result.root_fingerprint_sha256);
            println!("  root subject   : {}", result.used_root_subject);
            println!("  PCR policy ok  : {}", result.pcrs_ok);
            println!("  SPKI bound     : {}", result.spki_bound);
            Ok(())
        }
        Err(err) => Err(anyhow::anyhow!(format_attn_error(err))),
    }
}

/// Decide which root certificate PEM to trust based on CLI/env input.
fn resolve_root_pem_path() -> CliResult<PathBuf> {
    if let Ok(path) = env::var("NITRO_ROOT_PEM_PATH") {
        return Ok(PathBuf::from(path));
    }
    if let Some(arg) = env::args().nth(1) {
        return Ok(PathBuf::from(arg));
    }
    Err(anyhow::anyhow!(
        "provide root PEM path as first argument or set NITRO_ROOT_PEM_PATH"
    ))
}

/// Load the expected PCR json snapshot from disk.
fn load_expected_pcrs() -> CliResult<HashMap<u8, Vec<u8>>> {
    let (_, json) = read_json_from_env("NITRO_EXPECTED_PCRS_PATH")?;
    let mut map = HashMap::new();
    if let Some(pcr0) = json.get("pcr0").and_then(JsonValue::as_str) {
        map.insert(0u8, hex_to_bytes(pcr0)?);
    }
    if let Some(pcr1) = json.get("pcr1").and_then(JsonValue::as_str) {
        map.insert(1u8, hex_to_bytes(pcr1)?);
    }
    if let Some(pcr2) = json.get("pcr2").and_then(JsonValue::as_str) {
        map.insert(2u8, hex_to_bytes(pcr2)?);
    }
    Ok(map)
}

/// Convenience helper for fetching the expected measurement (PCR0) if present.
fn load_expected_measurement() -> Result<Vec<u8>, anyhow::Error> {
    let (_, json) = read_json_from_env("NITRO_MEASUREMENTS_PATH")?;
    let measurement = json
        .get("Measurements")
        .and_then(|m| m.get("PCR0"))
        .and_then(JsonValue::as_str)
        .ok_or_else(|| anyhow::anyhow!("Measurements.PCR0 not found in measurements JSON"))?;
    hex_to_bytes(measurement)
}

/// Read and parse a JSON file whose path is provided via environment variable.
fn read_json_from_env(var: &str) -> CliResult<(PathBuf, JsonValue)> {
    let path = env::var(var)
        .map(PathBuf::from)
        .map_err(|_| anyhow::anyhow!(format!("{var} not set")))?;
    let contents =
        fs::read_to_string(&path).map_err(|e| anyhow::anyhow!(format!("read {:?}: {e}", path)))?;
    let json: JsonValue = serde_json::from_str(&contents)
        .map_err(|e| anyhow::anyhow!(format!("parse JSON from {:?}: {e}", path)))?;
    Ok((path, json))
}

/// Decode a hex string that may optionally be prefixed with `0x`.
fn hex_to_bytes(hex_str: &str) -> CliResult<Vec<u8>> {
    let trimmed = hex_str.trim_start_matches("0x");
    let bytes =
        hex::decode(trimmed).map_err(|e| anyhow::anyhow!(format!("hex decode error: {e}")))?;
    Ok(bytes)
}

/// Generates a nonce, posts it to the local attestation endpoint, and returns both.
async fn fetch_attestation() -> CliResult<(String, String)> {
    let mut nonce = vec![0u8; 32];
    rand::thread_rng().fill_bytes(&mut nonce);
    let nonce_b64 = b64.encode(&nonce);

    let client = reqwest::Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(15))
        .build()?;

    let response = client
        .post("https://127.0.0.1:8443/attestation")
        .json(&serde_json::json!({ "nonce_b64": nonce_b64 }))
        .send()
        .await?
        .error_for_status()?;

    let body = response.text().await?;
    Ok((nonce_b64, body))
}

/// Human-friendly rendering of `AttnError` variants for CLI output.
fn format_attn_error(err: AttnError) -> String {
    match err {
        AttnError::NonceMismatch => "nonce mismatch".into(),
        AttnError::StaleTimestamp => "stale timestamp".into(),
        AttnError::CoseInvalid(reason) => format!("COSE validation failed: {reason}"),
        AttnError::ChainBuild(reason) => format!("certificate chain failed: {reason}"),
        AttnError::RootUntrusted => "attestation root not trusted".into(),
        AttnError::PcrPolicy(reason) => format!("PCR policy failed: {reason}"),
        AttnError::SpkiBinding => "TLS SPKI binding failed".into(),
        AttnError::Decode(reason) => format!("decode error: {reason}"),
        AttnError::Internal(reason) => format!("internal error: {reason}"),
    }
}

----- FILE: nsm-enclave-runner/Cargo.toml -----
[package]
name = "runner"
version = "0.1.0"
edition = "2021"

[dependencies]
# basics
anyhow = "1"
dotenvy = "0.15"         # load .env -> process env
envy    = "0.4"          # env -> struct via Serde
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt"] }

# async runtime
tokio = { version = "1.39", features = ["macros", "rt-multi-thread", "net", "io-util", "signal"] }
tokio-util = "0.7"       # CancellationToken

# web stack
axum = "0.7"
hyper = { version = "1", features = ["http1", "server"] }
hyper-util = { version = "0.1", features = ["tokio"] }
tower-http = { version = "0.5", features = ["trace", "timeout"] }  # (no compression)

# VSOCK + TLS
tokio-vsock = "0.5"
rustls = { version = "0.23", default-features = false, features = ["ring"] }
tokio-rustls = "0.26"

# self-signed cert + SPKI extraction
rcgen = "0.12"
x509-parser = "0.16"

# serde + json + helpers
serde = { version = "1", features = ["derive"] }
serde_json = "1"
base64 = "0.22"
hex = "0.4"
sha2 = "0.10"
zeroize = "1"

aws-nitro-enclaves-nsm-api =  "0.4"

serde_bytes = "0.11"
coset = "0.3"

[features]
default = []

----- FILE: nsm-enclave-runner/src/attest.rs -----
use anyhow::{anyhow, Result};
use aws_nitro_enclaves_nsm_api::api::{AttestationDoc, Request, Response};
use aws_nitro_enclaves_nsm_api::driver::{nsm_exit, nsm_init, nsm_process_request};
use coset::{CborSerializable, CoseSign1, TaggedCborSerializable};
use serde_bytes::ByteBuf;
use sha2::{Digest, Sha512};
use std::collections::BTreeMap;

#[derive(Debug, Clone)]
pub struct ParsedAttestationDoc {
    /// Module identifier expressed in the attestation payload.
    pub module_id: String,
    /// Digest algorithm used for the PCR bank (e.g. `SHA384`).
    pub digest: String,
    /// Timestamp emitted by NSM (milliseconds since Unix epoch).
    pub timestamp_ms: u64,
    /// Echoed nonce bound into the document.
    pub nonce: Vec<u8>,
    /// TLS SubjectPublicKeyInfo (DER) bound into the attestation.
    pub public_key: Vec<u8>,
    /// Optional user data blob returned by NSM.
    pub user_data: Option<Vec<u8>>,
    /// Attestation signing certificate DER.
    pub certificate: Vec<u8>,
    /// Intermediates/root certificates that complete the chain.
    pub cabundle: Vec<Vec<u8>>,
    /// PCR values keyed by PCR index.
    pub pcrs: BTreeMap<u32, Vec<u8>>,
}

/// Material emitted by NSM plus derived metadata we expose to HTTP handlers.
pub struct NsmAttestationOut {
    /// Raw COSE_Sign1 document returned by the NSM driver.
    pub quote: Vec<u8>,
    /// Policy identifier for consumers (currently static).
    pub policy: String,
    /// Crate version embedded so verifiers know the producer.
    pub runner_version: String,
    /// Parsed representation of the attestation document.
    pub doc: ParsedAttestationDoc,
}

/// Produces a fresh attestation document bound to the provided TLS SPKI and nonce.
///
/// This call must run inside an enclave (it talks to `/dev/nsm`). Validation is
/// performed on the inputs to avoid surprising driver errors, then the actual
/// driver interaction is moved onto a blocking thread to keep the async runtime
/// responsive.
pub async fn build_nsm_attestation(spki_der: &[u8], nonce: &[u8]) -> Result<NsmAttestationOut> {
    if !std::path::Path::new("/dev/nsm").exists() {
        return Err(anyhow!(
            "/dev/nsm not found — must run inside an AWS Nitro Enclave"
        ));
    }
    if spki_der.is_empty() {
        return Err(anyhow!("empty SPKI passed to build_nsm_attestation"));
    }
    if nonce.is_empty() || nonce.len() > 1024 {
        return Err(anyhow!("invalid nonce length"));
    }

    let spki = spki_der.to_vec();
    let nonce = nonce.to_vec();
    tokio::task::spawn_blocking(move || get_doc_sync_driver(&spki, &nonce))
        .await
        .map_err(|e| anyhow!("spawn_blocking join error: {e}"))?
}

/// Performs the synchronous NSM driver round-trip and parses the response.
fn get_doc_sync_driver(spki_der: &[u8], nonce: &[u8]) -> Result<NsmAttestationOut> {
    // Optional binding of SPKI+nonce in user_data for verifiers to recompute
    let mut h = Sha512::new();
    h.update(spki_der);
    h.update(nonce);
    let binding = h.finalize();

    let req = Request::Attestation {
        user_data: Some(ByteBuf::from(binding.to_vec())),
        nonce: Some(ByteBuf::from(nonce.to_vec())),
        public_key: Some(ByteBuf::from(spki_der.to_vec())),
    };

    let fd = nsm_init();
    if fd < 0 {
        return Err(anyhow!("nsm_init() failed (fd={fd})"));
    }

    let resp = nsm_process_request(fd, req);
    nsm_exit(fd);

    // Your API's Attestation only carries `document`
    let quote = match resp {
        Response::Attestation { document } => document,
        Response::Error(e) => return Err(anyhow!("NSM returned error: {:?}", e)),
        other => return Err(anyhow!("unexpected NSM response: {:?}", other)),
    };

    if quote.is_empty() {
        return Err(anyhow!("attestation document is empty"));
    }

    let doc = parse_attestation_doc(&quote, spki_der, nonce)?;

    Ok(NsmAttestationOut {
        quote,
        policy: "aws-nitro-nsm".to_string(),
        runner_version: env!("CARGO_PKG_VERSION").to_string(),
        doc,
    })
}

/// Decodes the COSE/CBOR attestation payload and validates a few invariants.
fn parse_attestation_doc(
    quote: &[u8],
    expected_spki: &[u8],
    expected_nonce: &[u8],
) -> Result<ParsedAttestationDoc> {
    let sign1 = CoseSign1::from_tagged_slice(quote)
        .or_else(|_| CoseSign1::from_slice(quote))
        .map_err(|e| anyhow!("parse NSM attestation as COSE_Sign1: {e:?}"))?;

    let payload = sign1
        .payload
        .as_ref()
        .ok_or_else(|| anyhow!("NSM attestation missing payload"))?
        .to_vec();

    let doc = AttestationDoc::from_binary(&payload)
        .map_err(|e| anyhow!("decode AttestationDoc payload: {e:?}"))?;

    let certificate = doc.certificate.to_vec();
    if certificate.is_empty() {
        return Err(anyhow!("attestation certificate missing"));
    }

    let cabundle: Vec<Vec<u8>> = doc.cabundle.iter().map(|c| c.to_vec()).collect();

    let nonce = doc
        .nonce
        .as_ref()
        .map(|n| n.to_vec())
        .ok_or_else(|| anyhow!("attestation nonce not present"))?;
    if nonce.as_slice() != expected_nonce {
        return Err(anyhow!("attestation nonce mismatch"));
    }

    let public_key = doc
        .public_key
        .as_ref()
        .map(|pk| pk.to_vec())
        .ok_or_else(|| anyhow!("attestation public_key field missing"))?;
    if public_key.as_slice() != expected_spki {
        return Err(anyhow!("attestation public_key mismatch"));
    }

    let mut pcrs = BTreeMap::new();
    for (idx, value) in doc.pcrs.iter() {
        pcrs.insert(*idx as u32, value.to_vec());
    }

    let digest = match doc.digest {
        aws_nitro_enclaves_nsm_api::api::Digest::SHA256 => "SHA256",
        aws_nitro_enclaves_nsm_api::api::Digest::SHA384 => "SHA384",
        aws_nitro_enclaves_nsm_api::api::Digest::SHA512 => "SHA512",
    };

    Ok(ParsedAttestationDoc {
        module_id: doc.module_id,
        digest: digest.to_string(),
        timestamp_ms: doc.timestamp,
        nonce,
        public_key,
        user_data: doc.user_data.as_ref().map(|u| u.to_vec()),
        certificate,
        cabundle,
        pcrs,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use aws_nitro_enclaves_nsm_api::api::Digest as AwsDigest;
    use coset::{CoseSign1Builder, HeaderBuilder};

    #[test]
    fn parse_attestation_doc_extracts_expected_fields() {
        let spki = vec![1u8, 2, 3, 4];
        let nonce = vec![5u8, 6, 7, 8];

        let mut pcrs = BTreeMap::new();
        pcrs.insert(0usize, vec![0xAB; 48]);
        pcrs.insert(1usize, vec![0xCD; 48]);

        let att_doc = AttestationDoc::new(
            "module-123".to_string(),
            AwsDigest::SHA384,
            1_700_000_000,
            pcrs.clone(),
            vec![0x01, 0x02, 0x03],
            vec![vec![0x04, 0x05]],
            Some(vec![0x99, 0x88]),
            Some(nonce.clone()),
            Some(spki.clone()),
        );
        let payload = att_doc.to_binary();

        let protected = HeaderBuilder::new()
            .algorithm(coset::iana::Algorithm::ES384)
            .build();

        let quote = CoseSign1Builder::new()
            .protected(protected)
            .payload(payload)
            .signature(vec![0u8; 96])
            .build()
            .to_tagged_vec()
            .expect("serialize cose");

        let parsed = parse_attestation_doc(&quote, &spki, &nonce).expect("parse doc");

        assert_eq!(parsed.module_id, "module-123");
        assert_eq!(parsed.digest, "SHA384");
        assert_eq!(parsed.timestamp_ms, 1_700_000_000);
        assert_eq!(parsed.nonce, nonce);
        assert_eq!(parsed.public_key, spki);
        assert_eq!(parsed.user_data.as_deref(), Some(&[0x99, 0x88][..]));
        assert_eq!(parsed.certificate, vec![0x01, 0x02, 0x03]);
        assert_eq!(parsed.cabundle, vec![vec![0x04, 0x05]]);
        assert_eq!(parsed.pcrs.get(&0), Some(&vec![0xAB; 48]));
        assert_eq!(parsed.pcrs.get(&1), Some(&vec![0xCD; 48]));
    }
}

----- FILE: nsm-enclave-runner/src/config.rs -----
use serde::Deserialize;
use std::net::SocketAddr;

#[derive(Clone, Debug, Deserialize)]
/// Runtime configuration loaded from `RUNNER_*` environment variables.
pub struct Config {
    pub log_level: Option<String>,

    #[serde(default = "def_public_addr")]
    pub public_addr: SocketAddr,
}

impl Config {
    /// Populates the configuration from environment variables, honoring `.env`.
    pub fn from_env() -> anyhow::Result<Self> {
        tracing::debug!("fetching config");
        let _ = dotenvy::dotenv();
        let cfg: Self = envy::prefixed("RUNNER_").from_env()?;
        Ok(cfg)
    }

    /// Handy defaults for local development/tests.
    pub fn dev() -> anyhow::Result<Self> {
        Ok(Config {
            log_level: Some("debug".to_string()),
            public_addr: def_public_addr(),
        })
    }

    /// Emit the effective configuration via tracing.
    pub fn info(&self) {
        tracing::info!(public_addr = %self.public_addr, "effective config");
        if self.public_addr.ip().is_unspecified() {
            tracing::warn!("binding to 0.0.0.0 — make sure this is intentional");
        }
    }
}

fn def_public_addr() -> SocketAddr {
    // Only the port is used for VSOCK (CID comes from VMADDR_CID_ANY); IP is ignored.
    "127.0.0.1:8443".parse().unwrap()
}

----- FILE: nsm-enclave-runner/src/handlers.rs -----
use crate::state::{AttestationFields, AttestationResponse, PublicState};
use axum::http::StatusCode;
use axum::{extract::State, Json};
use base64::engine::general_purpose;
use base64::Engine as _;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::collections::BTreeMap;
use tokio::signal;
use tracing::{debug, warn};

/// Liveness probe endpoint.
pub async fn ready() -> &'static str {
    "ready"
}

#[derive(Serialize)]
/// Static response body for `/health`.
pub struct Health {
    pub status: &'static str,
}

/// Readiness/health-check endpoint used by the parent instance.
pub async fn health(State(_state): State<PublicState>) -> (StatusCode, Json<Health>) {
    (StatusCode::OK, Json(Health { status: "ok" }))
}

#[derive(Deserialize)]
/// Incoming JSON body for `/attestation` requests.
pub struct AttestationRequest {
    /// Verifier-provided nonce (base64). Must be fresh/single-use on verifier side.
    pub nonce_b64: String,
}

/// Attestation-on-demand:
/// Accepts nonce -> calls NSM with { public_key = SPKI, nonce } -> returns COSE + metadata + TLS cert.
pub async fn attestation_handler(
    State(state): State<PublicState>,
    Json(req): Json<AttestationRequest>,
) -> (StatusCode, Json<serde_json::Value>) {
    let b64 = |bytes: &[u8]| general_purpose::STANDARD.encode(bytes);

    // Decode + sanity-check nonce
    let nonce = match general_purpose::STANDARD.decode(req.nonce_b64.as_bytes()) {
        Ok(n) if !n.is_empty() && n.len() <= 1024 => n,
        Ok(n) => {
            warn!(len = n.len(), "invalid nonce length");
            return (
                StatusCode::BAD_REQUEST,
                Json(json!({ "error": "invalid_nonce_length" })),
            );
        }
        Err(e) => {
            warn!(error=?e, "bad nonce base64");
            return (
                StatusCode::BAD_REQUEST,
                Json(json!({ "error": "invalid_nonce_base64" })),
            );
        }
    };

    // Call NSM: build fresh COSE_Sign1 attestation bound to our SPKI + the nonce
    match crate::attest::build_nsm_attestation(&state.spki_der, &nonce).await {
        Ok(nsm_out) => {
            debug!(
                quote_len = nsm_out.quote.len(),
                "fresh NSM attestation built"
            );

            // (optional) structured log – comment out if you removed logging helper
            // crate::logging::log_attestation_summary(&nsm_out.quote, &nonce, &state.spki_der, &state.cert_der, &nsm_out.policy, &nsm_out.runner_version);

            let doc = &nsm_out.doc;

            let cabundle_der_b64 = if doc.cabundle.is_empty() {
                None
            } else {
                Some(doc.cabundle.iter().map(|c| b64(c)).collect())
            };

            let mut pcrs_hex = BTreeMap::new();
            for (idx, value) in &doc.pcrs {
                pcrs_hex.insert(idx.to_string(), hex::encode(value));
            }
            let measurement_hex = pcrs_hex.get("0").cloned();

            let user_data_b64 = doc.user_data.as_ref().map(|ud| b64(ud));

            let out = AttestationResponse {
                attestation: AttestationFields {
                    quote_b64: b64(&nsm_out.quote),
                    nonce_b64: b64(&doc.nonce),
                    spki_der_b64: b64(&doc.public_key),
                    policy: nsm_out.policy,
                    runner_version: nsm_out.runner_version,
                    cabundle_der_b64,
                    pcrs_hex: if pcrs_hex.is_empty() {
                        None
                    } else {
                        Some(pcrs_hex)
                    },
                    measurement_hex,
                    module_id: Some(doc.module_id.clone()),
                    digest: Some(doc.digest.clone()),
                    timestamp_ms: Some(doc.timestamp_ms),
                    user_data_b64,
                    attestation_cert_der_b64: Some(b64(&doc.certificate)),
                },
                cert_der_b64: b64(&state.cert_der),
            };

            (
                StatusCode::OK,
                Json(serde_json::to_value(&out).expect("serialize AttestationResponse")),
            )
        }
        Err(e) => {
            warn!(error=?e, "attestation build failed");
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(json!({ "error": "attestation_failed" })),
            )
        }
    }
}

/// Blocks until Ctrl+C (or SIGTERM on Unix) to trigger graceful shutdown.
pub async fn shutdown_signal() {
    let ctrl_c = async { signal::ctrl_c().await.expect("install Ctrl+C handler") };
    #[cfg(unix)]
    let terminate = async {
        use tokio::signal::unix::{signal, SignalKind};
        let mut sigterm = signal(SignalKind::terminate()).expect("install signal handler");
        sigterm.recv().await;
    };
    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();
    tokio::select! { _ = ctrl_c => {}, _ = terminate => {}, };
}

----- FILE: nsm-enclave-runner/src/logging.rs -----
use crate::config::Config;
use sha2::{Digest, Sha256, Sha384};
use tracing::{debug, info};
use tracing_subscriber::EnvFilter;

/// Install a `tracing` subscriber using either `RUNNER_LOG_LEVEL` or `RUST_LOG`.
pub fn setup_logging(cfg: &Config) {
    let default = cfg.log_level.as_deref().unwrap_or("info");
    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(default));
    tracing_subscriber::fmt()
        .with_env_filter(filter)
        .with_target(false)
        .compact()
        .init();

    debug!("logging initialized with log level: {:?}", &cfg.log_level);
}

/// Log a concise, non-sensitive summary of the attestation materials.
pub fn log_attestation_summary(
    quote: &[u8],    // NSM COSE_Sign1 bytes
    nonce: &[u8],    // verifier-provided nonce
    spki_der: &[u8], // TLS SPKI bound in the NSM doc
    cert_der: &[u8], // TLS leaf presented by the server
    policy: &str,    // e.g. "aws-nitro-nsm"
    runner_version: &str,
) {
    let quote_len = quote.len();
    let quote_first = quote.first().copied().unwrap_or(0);

    let quote_sha256 = Sha256::digest(quote);
    let quote_sha384 = Sha384::digest(quote);
    let spki_sha256 = Sha256::digest(spki_der);
    let cert_sha256 = Sha256::digest(cert_der);

    info!(
        target: "attestation",
        policy,
        runner_version,
        quote_len,
        quote_first_byte = format_args!("0x{:02x}", quote_first),
        quote_sha256 = %hex::encode(quote_sha256),
        quote_sha384 = %hex::encode(quote_sha384),
        nonce_len = nonce.len(),
        spki_der_len = spki_der.len(),
        spki_sha256 = %hex::encode(spki_sha256),
        cert_der_len = cert_der.len(),
        cert_sha256 = %hex::encode(cert_sha256),
        "attestation summary"
    );
}

----- FILE: nsm-enclave-runner/src/main.rs -----
use anyhow::Result;

mod attest;
mod config;
mod handlers;
mod logging;
mod router;
mod runner;
mod server;
mod state;
mod tls;

use runner::Runner;

/// Parses configuration, initialises logging, and runs the enclave HTTP server.
#[tokio::main]
async fn main() -> Result<()> {
    let cfg = config::Config::from_env()?;
    logging::setup_logging(&cfg);
    cfg.info();

    Runner::new(cfg).await?.run().await
}

----- FILE: nsm-enclave-runner/src/router.rs -----
use axum::routing::{get, post};
use axum::Router;
use std::time::Duration;
use tower_http::{
    timeout::TimeoutLayer,
    trace::{DefaultMakeSpan, DefaultOnResponse, TraceLayer},
};
use tracing::Level;

use crate::handlers::*;
use crate::state::PublicState;

/// Constructs the public HTTP router (health + attestation) with middleware.
pub fn build_public_router(state: PublicState) -> Router {
    Router::new()
        .route("/health", get(health))
        .route("/ready", get(ready))
        .route("/attestation", post(attestation_handler))
        .with_state(state)
        .layer(
            TraceLayer::new_for_http()
                .make_span_with(DefaultMakeSpan::new().level(Level::INFO))
                .on_response(DefaultOnResponse::new().level(Level::INFO)),
        )
        .layer(TimeoutLayer::new(Duration::from_secs(15)))
}

----- FILE: nsm-enclave-runner/src/runner.rs -----
use anyhow::{Context, Result};
use rustls::crypto::{self, CryptoProvider};
use std::{net::SocketAddr, sync::Arc};
use tokio_util::sync::CancellationToken;
use tokio_vsock::{VsockAddr, VsockListener, VMADDR_CID_ANY};
use tracing::info;

use crate::{
    config::Config,
    handlers::shutdown_signal,
    router::build_public_router,
    server::serve_axum_https_with_listener, // <- now expects Arc<ServerConfig>
    state::PublicState,
    tls::{build_tls_keypair, tls_server_no_client_auth, TlsBundle},
};

/// Top-level orchestrator for the enclave HTTP server.
pub struct Runner {
    cfg: Config,
    pub_state: PublicState,
    public_listener: VsockListener,
    public_tls: Arc<rustls::ServerConfig>,
    shutdown: CancellationToken,
}

impl Runner {
    /// Bind a VSOCK listener on the provided port, annotating errors with context.
    async fn bind(addr: SocketAddr, description: &str) -> Result<VsockListener> {
        let port = addr.port() as u32;
        let vsock_addr = VsockAddr::new(VMADDR_CID_ANY, port);
        tracing::info!(vsock_port = port, "binding VSOCK {} listener", description);
        VsockListener::bind(vsock_addr)
            .with_context(|| format!("bind {} vsock addr {:?}", description, vsock_addr))
    }

    /// Builds a TLS keypair for the server. NO attestation here.
    async fn get_tls(cfg: &Config) -> Result<TlsBundle> {
        build_tls_keypair(cfg).await.context("TLS init failed")
    }

    /// Constructs the runtime, including TLS material, listeners, and shared state.
    pub async fn new(cfg: Config) -> Result<Self> {
        tracing::debug!("building runner");
        CryptoProvider::install_default(crypto::ring::default_provider())
            .expect("install ring crypto provider");

        // TLS only (no attestation)
        let tls = Self::get_tls(&cfg).await?;
        let public_tls = tls_server_no_client_auth(&tls.cert_der, &tls.key_der)?;

        // VSOCK listener
        let public_listener = Self::bind(cfg.public_addr, "public").await?;

        // minimal public state (cert + spki)
        let pub_state = PublicState {
            cert_der: Arc::<[u8]>::from(tls.cert_der.clone()),
            spki_der: Arc::<[u8]>::from(tls.spki_der.clone()),
            // If you removed the sealed store from state.rs, delete this field.
            // store: Arc::new(enclave_runner::sealed_state::MemStore::default()),
        };

        Ok(Self {
            cfg,
            pub_state,
            public_listener,
            public_tls,
            shutdown: CancellationToken::new(),
        })
    }

    /// Runs the enclave server until a shutdown signal is received.
    pub async fn run(self) -> Result<()> {
        tracing::debug!("starting runner");
        let shutdown = self.shutdown.clone();

        // public router only
        let public_app = build_public_router(self.pub_state.clone());

        // serve public vsock+TLS (static TLS cfg)
        tokio::spawn(serve_axum_https_with_listener(
            self.public_listener,
            public_app,
            self.public_tls.clone(),
            shutdown.clone(),
        ));

        // block until signal
        shutdown_signal().await;
        info!("shutdown signal received, exiting");
        self.shutdown.cancel();
        Ok(())
    }
}

----- FILE: nsm-enclave-runner/src/server.rs -----
use axum::Router;
use hyper::server::conn::http1;
use hyper_util::{rt::TokioIo, service::TowerToHyperService};
use rustls::ServerConfig;
use std::sync::Arc;
use tokio_rustls::TlsAcceptor;
use tokio_util::sync::CancellationToken;
use tokio_vsock::VsockListener;
use tracing::{info, warn};

/// Accepts VSOCK connections, upgrades them to TLS, and serves the provided Axum app.
pub async fn serve_axum_https_with_listener(
    mut listener: VsockListener,
    app: Router,
    tls_cfg: Arc<ServerConfig>, // <- static TLS only
    shutdown: CancellationToken,
) {
    info!("vsock https server listening");
    let acceptor = TlsAcceptor::from(tls_cfg);

    loop {
        tokio::select! {
            _ = shutdown.cancelled() => {
                info!("shutdown: stop accepting");
                break;
            }
            res = listener.accept() => {
                match res {
                    Ok((io, peer)) => {
                        // minimal log; remove if noisy
                        info!(cid=%peer.cid(), port=%peer.port(), "VSOCK accept");

                        let svc = app.clone().into_service();
                        let acceptor = acceptor.clone();
                        let child_cancel = shutdown.child_token();

                        tokio::spawn(async move {
                            match acceptor.accept(io).await {
                                Ok(tls_io) => {
                                    let io = TokioIo::new(tls_io);
                                    let hyper_svc = TowerToHyperService::new(svc);
                                    if let Err(e) = http1::Builder::new()
                                        .serve_connection(io, hyper_svc)
                                        .await
                                    {
                                        warn!(error = ?e, "http1 connection error");
                                    }
                                }
                                Err(e) => warn!(error=?e, "tls accept failed"),
                            }
                            drop(child_cancel);
                        });
                    }
                    Err(e) => warn!(error=?e, "listener.accept error; continuing"),
                }
            }
        }
    }
    info!("listener loop exited");
}

----- FILE: nsm-enclave-runner/src/state.rs -----
use std::collections::BTreeMap;
use std::sync::Arc;

#[derive(Clone)]
/// Immutable state cloned into HTTP handlers.
pub struct PublicState {
    /// Self-signed TLS certificate (DER) the server presents.
    pub cert_der: Arc<[u8]>,
    /// SPKI (DER) of the TLS cert's public key; bind this in NSM attestation.
    pub spki_der: Arc<[u8]>,
    // If you don't actually use a sealed store elsewhere, delete it entirely.
    // pub store: Arc<sealed_state::MemStore>,
}

#[derive(serde::Serialize)]
/// JSON response envelope sent back to verifiers.
pub struct AttestationResponse {
    /// Fields coming from the fresh NSM attestation (built per verifier nonce).
    pub attestation: AttestationFields,
    /// The server's TLS leaf certificate (DER, base64) to pin after validation.
    pub cert_der_b64: String,
}

#[derive(serde::Serialize)]
/// Detailed attestation fields returned by `/attestation`.
pub struct AttestationFields {
    /// Raw NSM COSE_Sign1 attestation (base64).
    pub quote_b64: String,
    /// Echo of the verifier-supplied nonce (base64).
    pub nonce_b64: String,
    /// SPKI (DER) the enclave included in the attestation (base64).
    pub spki_der_b64: String,
    /// Static policy tag for clarity (e.g., "aws-nitro-nsm").
    pub policy: String,
    /// Runner version string.
    pub runner_version: String,
    /// CABundle returned by NSM (base64 DER, leaf excluded).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cabundle_der_b64: Option<Vec<String>>,
    /// Hex-encoded PCR values keyed by PCR index.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcrs_hex: Option<BTreeMap<String, String>>,
    /// Convenience alias for PCR0 (measurement) if present.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub measurement_hex: Option<String>,
    /// Module identifier emitted by NSM.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub module_id: Option<String>,
    /// Digest algorithm used by NSM for PCR bank.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub digest: Option<String>,
    /// Timestamp of the attestation document (ms since Unix epoch).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp_ms: Option<u64>,
    /// Optional user data (base64) bound into the attestation document.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_data_b64: Option<String>,
    /// Attestation signing certificate DER emitted by NSM (base64).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attestation_cert_der_b64: Option<String>,
}

----- FILE: nsm-enclave-runner/src/tls.rs -----
use crate::config::Config;
use anyhow::{Context, Result};
use rustls::pki_types::{CertificateDer, PrivatePkcs8KeyDer};
use rustls::ServerConfig;
use std::sync::Arc;
use tracing::{debug, info, warn};
use zeroize::Zeroize;

use rcgen::{Certificate, CertificateParams};
use x509_parser::prelude::*;

/// TLS-only bundle (no attestation)
pub struct TlsBundle {
    pub cert_der: Vec<u8>,
    pub key_der: Vec<u8>,
    pub spki_der: Vec<u8>,
}

/// Minimal self-signed cert/key. No CN/SAN/EKU; trust comes from NSM (SPKI binding).
pub async fn build_tls_keypair(_cfg: &Config) -> Result<TlsBundle> {
    info!("Generating minimal self-signed TLS certificate");

    let params = CertificateParams::default();
    let cert = Certificate::from_params(params).context("rcgen: from_params")?;

    let cert_der = cert.serialize_der().context("rcgen: serialize cert der")?;
    let mut key_der = cert.serialize_private_key_der();
    let spki_der = extract_spki_der(&cert_der).context("extract SPKI from cert")?;

    let out = TlsBundle {
        cert_der,
        key_der: key_der.clone(),
        spki_der,
    };
    key_der.zeroize();
    Ok(out)
}

/// Extract SubjectPublicKeyInfo (SPKI) DER from a certificate DER.
fn extract_spki_der(cert_der: &[u8]) -> Result<Vec<u8>> {
    let (_, cert) = X509Certificate::from_der(cert_der).context("parse x509 der")?;
    Ok(cert.tbs_certificate.subject_pki.raw.to_vec())
}

/// Public listener TLS: no client auth (vsock-only).
pub fn tls_server_no_client_auth(cert_der: &[u8], key_der: &[u8]) -> Result<Arc<ServerConfig>> {
    info!("Configuring TLS for public listener (no client auth)");

    debug!(
        "Parsing server certificate from DER ({} bytes)",
        cert_der.len()
    );
    let certs = vec![CertificateDer::from(cert_der.to_vec())];
    if certs.is_empty() {
        warn!("No certificates found in provided DER data");
        anyhow::bail!("No certificates provided for TLS server");
    }

    debug!("Parsing private key from DER ({} bytes)", key_der.len());
    let mut key_bytes = key_der.to_vec();
    let key = PrivatePkcs8KeyDer::from(key_bytes.clone()).into();
    key_bytes.zeroize();

    debug!("Building rustls ServerConfig...");
    let mut cfg = ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(certs, key)
        .context("failed to configure rustls with certificate and key")?;

    cfg.alpn_protocols = vec![b"http/1.1".to_vec()];
    Ok(Arc::new(cfg))
}

### END OF SNAPSHOT
